<html>

  <head>
    <meta charset="UTF-8">
    <title>loop test</title>

    <style>
    table, td {
        border: 1px solid black;
    }
    </style>

    <!-- scripts must be included in reverse order of call stack for scope visibility -->
    <script src="debug.js"></script>
    <script src="helpers.js"></script>
    <script src="BCLegs.js"></script>
    <script src="BCEndRings.js"></script>
    <script src="BirdcageBuilder.js"></script>
    <script src="BBGuiHandler.js"></script>


  <!-- Birdcage Builder -->
  <!-- v0.0.2 GUI Test only -->
  <!-- Doug Brantner 4/17/2023 -->
  <!-- NYU Langone Health CAI2R -->
  <!-- cai2r.net -->

  </head>





  <body>
    <h1>Test Loop/Modulo Behavior</h1>

    <h2>Debug</h2>
    <p id="debug1"></p>

    <br>
    <table id="table1"></table>

  <script>
    //debug('Starting loop...');
    debug('');

    var n_legs = 8;
    var n = n_legs;


    debug('n_legs = ' + n_legs);
    debug('n = ' + n);

    var mytab = document.getElementById('table1');
    var mytab_body = mytab.createTBody();
    var header = mytab.createTHead();
    var row = header.insertRow(0);
    var cell = row.insertCell(0);
    cell.innerHTML = 'k';

    cell = row.insertCell(1);
    cell.innerHTML = 'k+1';
    
    cell = row.insertCell(2);
    cell.innerHTML = '<b>mod(k+1, n)</b>';

    cell = row.insertCell(3);
    cell.innerHTML = '(k+1) % n';

    cell = row.insertCell(4);
    cell.innerHTML = 'k+n';

    cell = row.insertCell(5);
    cell.innerHTML = '<b>mod(k+n, n)</b>';

    cell = row.insertCell(6);
    cell.innerHTML = '(k+n) % n';

    cell = row.insertCell(7);
    cell.innerHTML = 'mod(k, n)';

    cell = row.insertCell(8);
    cell.innerHTML = 'k % n';
    
    cell = row.insertCell(9);
    cell.innerHTML = '(k+n) % n == k%n'; 

    cell = row.insertCell(10);
    cell.innerHTML = 'mod(k, n) == k % n';


		var k, k1;
    var rowindex = 0;
		for (k=-n; k < n; k++){

			//debug('k: ' + k);
			//debug('--------');

      row = mytab_body.insertRow(rowindex);
      cell = row.insertCell(0);
      cell.innerHTML = k;

      cell = row.insertCell(1);
      cell.innerHTML = k+1;

			// pre-compute modulo indexes (NOTE javascript % operator does NOT behave as expected)
			// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder
			idx1 = mod(k+1, n);
			idxN = mod(k+n, n);

      cell = row.insertCell(2);
      //cell.innerHTML = 'mod(k+1, n)';
      cell.innerHTML = idx1;

      cell = row.insertCell(3);
      cell.innerHTML = (k+1) % n;

      cell = row.insertCell(4);
      cell.innerHTML = k+n;

      cell = row.insertCell(5);
      cell.innerHTML = idxN;

      cell = row.insertCell(6);
      cell.innerHTML = (k+n) % n;

      cell = row.insertCell(7);
      cell.innerHTML = mod(k, n);

      cell = row.insertCell(8);
      cell.innerHTML = k % n;

      cell = row.insertCell(9);
      cell.innerHTML = (k+n) % n == k%n; 

      cell = row.insertCell(10);
      cell.innerHTML = mod(k, n) == k%n;

      //debug1('<tr><td> ' + k + ' </td>');
      //debug1('<td> ' + (k+1) +  ' </td>');
      //debug1('<td> ' + idx1 +  ' </td>');

      //debug('</tr>');
      
			//debug('k = ' + k);
			//debug('n = ' + n);
			//debug('k+1 = ' + (k+1));
			//debug('idx1: (k+1) mod n: ' + idx1);


			//debug('test idx1        : ' + mod(k+1, n));
			//debug('test idx1-2      : ' + mod(1, 8));
			//debug('idxN: mod(k+n, n): ' + idxN);
			//debug('test idxN:       : ' + mod(k+n, n));
			//debug('test idxN-2      : ' + mod(8, 8));

			idx2 = mod(k+2, n);
			idxK = mod(k, n);
			iKN2N = mod(k+n/2, n);
			iKN1N = mod(k+n-1, n);

			////Mutual Inductance of Opposite Rings
			//d = Math.sqrt(Math.pow(legs.leg_x[idx1]-legs.leg_x[iKN2N],2)+Math.pow(legs.leg_y[idx1]-legs.leg_y[iKN2N],2));
			//Lop = 0;
			//if (Math.abs(this.er_currents[idxK])>(1/10000)) {
			//	Lop = 2*this.er_arclen*(Math.log(this.er_arclen/d+Math.sqrt(1+Math.pow(this.er_arclen/d, 2)))-Math.sqrt(1+Math.pow(d/this.er_arclen,2))+d/this.er_arclen);
			//
			//}
			//
			//debug('d: ' + d);
			//debug('Lop: ' + Lop);
		
			////Mutual Inductance of Adjacent Rings
			//// TODO m1 is zero when k=1 in app default value test
			//m1 = Math.sqrt(Math.pow(legs.leg_x[idx1]-legs.leg_x[idxN],2)+Math.pow(legs.leg_y[idx1]-legs.leg_y[idxN],2));
			//l1 = Math.sqrt(Math.pow(legs.leg_x[idx1]-legs.leg_x[idx2],2)+Math.pow(legs.leg_y[idx1]-legs.leg_y[idx2],2));
			//R1 = Math.sqrt(Math.pow(legs.leg_x[idx2]-legs.leg_x[idxK],2)+Math.pow(legs.leg_y[idx2]-legs.leg_y[idxK],2));

			//debug('m1 first calc:');
			//debug('Math.pow(legs.leg_x[idx1]-legs.leg_x[idxN],2): ' + Math.pow(legs.leg_x[idx1]-legs.leg_x[idxN],2));
		  //  debug('Math.pow(legs.leg_y[idx1]-legs.leg_y[idxN],2): ' + Math.pow(legs.leg_y[idx1]-legs.leg_y[idxN],2));
			//debug('m1: ' + m1);
			//debug('l1: ' + l1);
			//debug('R1: ' + R1);
			//
			//ang1 = (Math.pow(l1,2)+Math.pow(m1,2)-Math.pow(R1,2))/(2*l1*m1);

			//debug('Math.pow(l1,2): ' + Math.pow(l1,2));
			//debug('Math.pow(m1,2): ' + Math.pow(m1,2));
			//debug('Math.pow(R1,2): ' + Math.pow(R1,2));
			//debug('(2*l1*m1): ' +      (2*l1*m1));
			//debug('ang1: ' + ang1);

			//Mnext = Math.abs(2*ang1*(l1*this.harct(m1/(l1+R1))+m1*this.harct(m1/(m1+R1)) ));
			//
			//// TODO m1 is zero when k=1 in app default value test (zero appears in first one above too)
			//m1 = Math.sqrt(Math.pow(legs.leg_x[idxK]-legs.leg_x[iKN1N],2)+Math.pow(legs.leg_y[idxK]-legs.leg_y[iKN1N],2));

			//l1 = Math.sqrt(Math.pow(legs.leg_x[idxK]-legs.leg_x[idx1],2)+Math.pow(legs.leg_y[idxK]-legs.leg_y[idx1],2));
			//R1 = Math.sqrt(Math.pow(legs.leg_x[idx1]-legs.leg_x[iKN1N],2)+Math.pow(legs.leg_y[idx1]-legs.leg_y[iKN1N],2));

			//debug('Mnext: ' + Mnext);
			//debug('m1: ' + m1);
			//debug('l1: ' + l1);
			//debug('R1: ' + R1);
			//
			//ang1 = (Math.pow(l1,2) + Math.pow(m1,2) - Math.pow(R1,2))/(2*l1*m1);
			//Mprev = Math.abs(2*ang1*(l1*this.harct(m1/(l1+R1))+m1*this.harct(m1/(m1+R1)) ));	

			//debug('ang1: ' + ang1);
			//debug('Mprev: ' + Mprev);





			//

			//Ladj=0;
			//if (Math.abs(this.er_currents[idxK])>(1/100000)) {
			//	Ladj = (Mnext*this.er_currents[idx1]+Mprev*this.er_currents[iKN1N])/this.er_currents[idxK];
			//}
			//


			////Mutual Inductance of Non Adjacent Rings
			//Lnadj = 0;
			//for (k1 = 3; k1<n; k1++) {

			//	// pre-compute modulo indexes (see above, do NOT use % operator)
			//	
			//	iKpK1N = mod(k+k1, n);
			//	iKpK1m1N = mod(k+k1-1, n);
			//
			//	M = Math.sqrt(Math.pow(legs.leg_x[idx1]-legs.leg_x[idxK],2)+Math.pow(legs.leg_y[idx1]-legs.leg_y[idxK],2));
			//	L = Math.sqrt(Math.pow(legs.leg_x[iKpK1N]-legs.leg_x[iKpK1m1N],2)+Math.pow(legs.leg_y[iKpK1N]-legs.leg_y[iKpK1m1N],2));
			//	R3 = (Math.pow(legs.leg_x[idxK]-legs.leg_x[iKpK1m1N],2)+Math.pow(legs.leg_y[idxK]-legs.leg_y[iKpK1m1N],2));
			//	R4 = (Math.pow(legs.leg_x[idx1]-legs.leg_x[iKpK1m1N],2)+Math.pow(legs.leg_y[idx1]-legs.leg_y[iKpK1m1N],2));
			//	R2 = (Math.pow(legs.leg_x[idxK]-legs.leg_x[iKpK1N],2)+Math.pow(legs.leg_y[idxK]-legs.leg_y[iKpK1N],2));
			//	R1 = (Math.pow(legs.leg_x[idx1]-legs.leg_x[iKpK1N],2)+Math.pow(legs.leg_y[idx1]-legs.leg_y[iKpK1N],2));
			//	
			//	a2 = R4 - R3 + R2 - R1;	
			//	
			//	ang = a2/(L*M);
			//
			//	p = 4*Math.pow(L,2)*Math.pow(M,2)-Math.pow(a2,2);
			//	if (p==0) {
			//		mu = 0;
			//		v = 0;
			//	} else {
			//		mu = L*(2*Math.pow(M,2)*(R2-R3-Math.pow(L,2))+a2*(R4-R3-Math.pow(M,2)))/(4*Math.pow(L,2)*Math.pow(M,2)-Math.pow(a2,2));
			//		v = M*(2*Math.pow(L,2)*(R4-R3-Math.pow(M,2))+a2*(R2-R3-Math.pow(L,2)))/(4*Math.pow(L,2)*Math.pow(M,2)-Math.pow(a2,2));
			//	}
			//
			//	t4 = Math.sqrt(R4);
			//	t3 = Math.sqrt(R3);
			//	t2 = Math.sqrt(R2);			
			//	t1 = Math.sqrt(R1);
			//	s1 = (mu+L)*this.harct(M/(t1+t2));
			//	s2 = (v+M)*this.harct(L/(t1+t4));
			//	s3 = (mu)*this.harct(M/(t3+t4));
			//	s4 = (v)*this.harct(L/(t3+t2));
			//	lmu[k1] = ang*(s1+s2-s3-s4);
			//	if (k1==(n/2+1)) {
			//		lmu[k1]=0;
			//	}
			//	
			//	
			//	if (Math.abs(this.er_currents[idxK])>(1/100000)) {
			//		Lnadj = Lnadj + lmu[k1]*Math.abs(this.er_currents[iKpK1m1N]/this.er_currents[idxK]);		
			//	}
			//
			//
			//
			//}
		

			//this.er_mutual_inductance[k] = Lnadj + this.er_self_inductance + Lop + Ladj;
		
      rowindex += 1;
		
			//debug('');
		} // end of loop

    //debug('</table>');

  </script>

  </body>


</html>
